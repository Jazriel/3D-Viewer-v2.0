\capitulo{3}{Conceptos teóricos}

A continuación desarrollaremos aquellos conceptos necesarios para comprender el funcionamiento del proyecto.

\section{Representación tridimensional de objetos}
Comenzaremos explicando brevemente cómo se capturan los datos sobre la pieza para generar su modelo digital. Mediante un escáner de barrido, se realizan múltiples mediciones para determinar la distancia al modelo. De forma paralela, mientras se capturan dichos, también se realizan múltiples fotografías con el fin de añadir los detalles que provee el color al modelo.

Tras una serie de pasos, se combina toda la información y se almacena en un mismo archivo, con extensión \texttt{<<.ply>>}, cuyo formato explicamos en la sección \ref{sec:formato-ply}. Tras tener el modelo ya almacenado, puede suceder que tengamos elementos en el fichero que no se correspondan con el propio modelo, sino que sean ruido; por ello, deberemos prestar atención.

\section{Formato \textit{PLY}}\label{sec:formato-ply}
Es un formato de archivo que almacena datos sobre modelos tridimensionales, y este es el formato elegido para cargar modelos en la aplicación.

Los archivos se forman por dos elementos, cabecera y cuerpo. En el primero se definen los elementos que contiene el fichero, mientras que en el segundo aparecen dichos datos.

La cabecera aparece siempre en \textit{ASCII}, independientemente de si el fichero \textit{PLY} es \textit{ASCII} o binario. Es un conjunto de líneas finalizadas mediante retornos de carro, y comienza con un <<número mágico>>~\cite{wiki:Magic-number}. Ésta será una línea con:

\verb|ply|

La segunda línea deberá ser el formato del fichero. Este nos dirá la codificación del cuerpo, así como la versión del estándar (actualmente la 1.0).

Lo que aquí llamamos codificación, en realidad se conoce como \textit{<<endianness>>}~\cite{wiki:endianness}, o lo que es lo mismo, el orden de los \textit{bytes} que representan los elementos. La codificación puede ser \texttt{<<binary\_little\_endian>>}, \texttt{<<binary\_big\_endian>>} o, como vemos en el siguiente ejemplo, \texttt{<<ascii>>}.

\verb|format ascii 1.0|

También podemos tener comentarios en el fichero, que serán de línea y comenzarán por la palabra clave \texttt{<<comment>>}.

\verb|comment this is not a comment, isn't it?|

Después, tendremos definidos los elementos que aparecerán en el cuerpo. Por ejemplo, una figura que contenga 156 vértices tendrá la declaración:

\verb|element vertex 156|

\noindent Seguida de la sentencia que determina el tipo de la coordenada \texttt{<<x>>}:

\verb|property float32 x|

\noindent Su coordenada \texttt{<<y>>}:

\verb|property float32 y|

\noindent Y su coordenada \texttt{<<z>>}:

\verb|property float32 z|

Tal y como hemos descrito los vértices, un ejemplo podría ser el mostrado en la figura~\ref{fig:coordenadas-ply}.
\imagenpersonalizada{coordenadas-ply}{Una lista de coordenadas en \textit{PLY}.}{0.7}

Como esto solamente son los vértices, necesitamos de otro elemento que determine la relación entre ellos, que será la lista de caras, definida por:

\verb|element face 400|

\noindent Seguida por la declaración de dicha propiedad:

\verb|property list uint8 int32 vertex_index|

Esta propiedad sería una lista de caras o índices de vértices, cuyo primer número en cada fila determina la cantidad de índices que compondrán el polígono (cara). Podemos ver un ejemplo en la figura~\ref{fig:caras-ply}. En el formato binario necesitaremos seguir más al pie de la letra dicha cantidad; ahora sí necesitaremos el campo \texttt{<<uint8>>} que aparece al principio de cada cara, pues primero tenemos que saber el número de las mismas a leer antes de parsearlo.
\imagenpersonalizada{caras-ply}{Una lista de caras en \textit{PLY}.}{0.28}

\noindent Finalmente, cerraríamos la cabecera mediante:

\verb|end_header|

A continuación, tendríamos el cuerpo, en el que se mostrarían los elementos definidos en la cabecera. Ahora sí, el cuerpo podría venir definido en binario (\textit{<<little endian>>} o \textit{<<big endian>>}) o \textit{ASCII}, según lo que dicte la cabecera.

En el caso de la codificación \textit{ASCII}, tendríamos una serie de líneas cuyo fin sería de nuevo el retorno de carro \texttt{<<\textbackslash r>>} y su separador fuesen espacios --aunque no aparece ninguna referencia específica en el estándar, es lo que hemos encontrado--. 

Por contra, en la codificación binaria nos tendremos que fiar de los tipos definidos para cada elemento en la cabecera.

Cada una de esas líneas sería un elemento de los que aparecen descritos en la cabecera. Deben aparecer en la misma cantidad y orden en que estén declarados para un correcto procesado.

Finalmente, diremos que el formato soporta elementos definidos por el usuario, aunque nosotros no los utilicemos.

\section{Formato \textit{STL}}
Es otro formato de archivo~\cite{wiki:STL} que almacena datos de modelos tridimensionales. Ahora que pasamos a soportarlo, lo explicaremos de forma resumida, además de resaltar las principales diferencias con \textit{PLY}.

\textit{STL} también tiene versiones \textit{ASCII} y binaria. Sin embargo, esta última solamente puede ser representada mediante codificación \textit{<<little endian>>}, el estándar asumido.

En la versión \textit{ASCII}, el archivo comienza mediante \texttt{<<solid \textit{nombre}>>} o mediante \texttt{<<solid >>} si no definimos el nombre (este es opcional). No obstante, el espacio después de \texttt{<<solid>>} es obligatorio.

A continuación se mostrarán las facetas, similares a las representadas en código~\ref{ASCII-STL-facets}. En ellas, cada \texttt{<<normal>>} o \texttt{<<vértice>>} es un número en coma flotante en el formato \texttt{<<signo-mantisa-e-signo-exponente>>}.

\begin{lstlisting}[mathescape=true, frame=single, float, caption=Facetas en \textit{ASCII STL}, label=ASCII-STL-facets]
facet normal $normal_{i}$ $normal_{j}$ $normal_{k}$
  outer loop
    vertex $vertice1_{x}$ $vertice1_{y}$ $vertice1_{z}$
    vertex $vertice2_{x}$ $vertice2_{y}$ $vertice2_{z}$
    vertex $vertice3_{x}$ $vertice3_{y}$ $vertice3_{z}$
  endloop
endfacet
\end{lstlisting}

El archivo terminará con la línea \texttt{<<endsolid nombre>>}. Insistimos en la opcionalidad del nombre.

Si el archivo está codificado en binario, su estructura será como la que mostramos en código~\ref{binary-STL}. Los 80 caracteres del inicio no deben comenzar bajo ningún concepto por la palabra \texttt{<<solid>>} para evitar confusión con la codificación en \textit{ASCII}. El contador de atributos nos dirá el número de atributos que el archivo tiene (en el estándar, este será 0).

\begin{lstlisting}[mathescape=true, frame=single, float, caption=Formato \textit{STL} binario, label=binary-STL]
UINT8[8] - Cabecera
UINT32 - Número de triángulos

Ppor cada triángulo
  REAL32[3] - Vector normal
  REAL32[3] -  $vertice1_{x}$ $vertice1_{y}$ $vertice1_{z}$
  REAL32[3] -  $vertice2_{x}$ $vertice2_{y}$ $vertice2_{z}$
  REAL32[3] -  $vertice3_{x}$ $vertice3_{y}$ $vertice3_{z}$
  UINT16 - Contador de atributos
fin
\end{lstlisting}