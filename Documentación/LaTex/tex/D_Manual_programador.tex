\apendice{Documentación técnica de programación}

\section{Introducción}
A continuación documentaremos la aplicación tanto para alguien que vaya a realizar su despliegue~\ref{manual-despliegue}, como para aquel que la vaya a modificar (ver sección~\ref{manual-programador}).

\section{Manual de despliegue}\label{manual-despliegue}
Vamos a ver los pasos a realizar para desplegar la aplicación desde cero. No obstante y con el fin de facilitar el despliegue, tenemos un par de \textit{scripts} para dicha tarea: 
podemos emplear \texttt{<<WebPage/install\_run.bat>>} para Windows, además de \texttt{<<WebPage/install\_run.sh>>} para Linux. Si la ejecución del \textit{script} lanza algún error, siempre podemos realizar una instalación paso a paso.

\subsection{Lanzar un terminal o consola}
Para comenzar, lo primero que tendremos que hacer es ejecutar una consola, algo realmente fácil. En Windows por ejemplo, pulsando \texttt{<<Windows + R>>} podemos ejecutar un comando. En este caso, queremos lanzar la consola de comandos, así que teclearemos \texttt{<<cmd>>} en el recuadro de texto y pulsaremos ejecutar. Así de fácil.
En versiones recientes de Windows, también podremos utilizar la \texttt{<<Powershell>>} si así lo deseamos. En el menú de inicio podemos buscar la aplicación como tal.
En Linux lanzar el terminal incluso suele estar asociado a un atajo de teclado: \texttt{<<Ctrl + Alt + T>>}. En caso contrario, podemos buscar en el menú de aplicaciones, suele estar nombrado como \texttt{<<Terminal>>}, otras veces como \texttt{<<XTerm>>}, etc.
Finalmente, en Mac se llama \texttt{<<Terminal>>}.

\subsection{Instalando Python}\label{instalar-python}
Los componentes en que se basa el servidor web necesitan Python, que será nuestra primera parada. Para ello, iremos a la página de descargas de Python, y nos descargaremos la versión \texttt{<<3.5.2>>}\footnote{\url{https://www.python.org/downloads/release/python-352/}} para nuestro sistema operativo. Tras la descarga, procederemos a su instalación. Durante el proceso en Windows, se preguntará si desea añadir Python al \texttt{PATH} del sistema. Si desea utilizar los comandos tal cual se escriben aquí, debe aceptar esta opción. Si no, en vez de escribir \texttt{<<python3>>} o \texttt{<<pip3>>}, deberá introducir la ruta absoluta de los binarios.

\subsection{Creando un entorno virtual}\label{crear-venv}
Tras completar el paso anterior, vamos a instalar algunos componentes. Si ya tenemos más instalaciones de Python, o si simplemente queremos que nuestra instalación siga limpia, deberemos hacer un pequeño rodeo creando un  entorno virtual sobre el que recaigan los componentes. Insistimos, si has leído estos casos y no te sientes identificado, puedes saltarse esta explicación.

\noindent\verb|$ python3 -m venv mi_venv|

Lo que hace el código arriba descrito\footnote{Es posible que el comando \texttt{<<python3>>} no sea reconocido en ocasiones; sería posible que el alias real para la instalación sea \texttt{<<python>>.}} es crear un entorno virtual en la carpeta actual bajo la carpeta visor. Una vez creado, queremos que las dependencias se instalen en él así que necesitamos activarlo primero. Para ello, escogemos la opción según nuestro sistema operativo, escogiéndola de la tabla~\ref{tabla:comandos-source} y nuestra consola para ejecutarla en un terminal.

\begin{tabular}{lll}
		\otoprule
	Posix   & bash/zsh   & \verb|$ source mi_venv/bin/activate|          \\
		\cline{2-3}
	& fish       & \verb|$ . mi_venv/bin/activate.fish|          \\
		\cline{2-3}
	& csh/tcshq  & \verb|$ source mi_venv/bin/activate.csh|      \\
	\midrule
	Windows & cmd.exe    & \verb|C:\> mi_venv\Scripts\activate.bat|    \\
		\cline{2-3}
	& Powershell & \verb|PS C:\> mi_venv\Scripts\Activate.ps1| \\
		\bottomrule
\end{tabular}\label{tabla:comandos-source}

Ahora, si instalamos las dependencias se hará dentro de este entorno, sin <<manchar>> nuestra instalación original. Cuando necesitemos salir de dicho entorno virtual, teclearemos \texttt{<<deactivate>>}, o simplemente cerraremos el terminal.



\subsection{Instalando las dependencias Python}\label{instalar-dependencias-python}
En la carpeta \texttt{<<Webpage>>}, encontramos un archivo \texttt{<<requirements.txt>>}. A éste debemos hacer mención con el comando\footnote{Con el comando \texttt{<<pip3>>} es posible que también necesitemos escribirlo sin el \texttt{<<3>>}.}:

\noindent\verb|$ pip3 install -r <ruta proyecto>/Webpage/requirements.txt|

Con las dependencias ya instaladas, tenemos que dar permisos de acceso a los usuarios que deseemos.

\subsection{Dando permisos a usuarios}
Si queremos que un usuario pueda utilizar la aplicación, tenemos que incluirlo en la base de datos. Con el fin de facilitar añadir usuarios a dicha tabla, tenemos un método del que nos podemos aprovechar en el módulo \texttt{<<MyApp>>}, llamado \texttt{<<import\_users\_to\_db>>}. Para llamarlo, desde la línea de comandos debemos seleccionar la carpeta \texttt{<<WebPage>>} mediante el comando \texttt{<<cd>>}. Como argumento al mismo, escribiremos la carpeta hacia el cual nos queremos dirigir. Si lo que deseamos es ir un directorio hacia arriba, escribiremos como parámetro \texttt{<<..>>}.

Si la consola nos indica por ejemplo que estamos sobre la carpeta MyApp del proyecto, subiremos una posición escribiendo:

\noindent\verb|$ cd ..|

Si la consola nos indica que estamos en la carpeta que contiene el proyecto (típicamente \texttt{<<3D-Viewer>>)}, entonces bajaríamos mediante:

\noindent\verb|$ cd WebPage|

Nótese que podríamos encadenar varios de ellos. Por ejemplo, si estuviésemos en la carpeta `Documentación', entonces:

\noindent\verb|$ cd ../WebPage|

Volviendo a la explicación, lo que tenemos que hacer es cambiar la carpeta seleccionado en la consola.

\noindent\verb|$ cd <ruta proyecto>/WebPage|

Una vez hecho esto, podemos inicial el terminal interactivo de python mediante:

\noindent\verb|$ python3|

Dentro del mismo, podremos importar el módulo \texttt{<<MyApp>>} mediante:

\noindent\verb|>>>import MyApp|

Ahora, emplearemos el método que queríamos, \texttt{<<import\_users\_to\_db>>}. Podemos hacerlo sin parámetro:

\noindent\verb|>>>MyApp.import_users_to_db()|

Y, entonces buscará el archivo \texttt{<<WebPage\slash instance\slash users\textunderscore to\textunderscore import.csv>>} por defecto. Si por el contrario, deseamos que busque otro archivo (siempre dentro de la carpeta \texttt{<<instance>>}), se lo podemos pasar como parámetro:

\noindent\verb|>>>MyApp.import_users_to_db('otro_archivo')|

De esta manera, los usuarios dentro de este archivo serán importados a la base de datos para otorgarles permiso de acceso. El archivo que vamos a emplear para decirle los usuarios, tiene que tener un formato especial: \textit{CSV}. Éste es realmente sencillo de realizar mediante un programa de hoja de cálculo como <<Excel>>, <<Numbers>> o <<Calc>>, por mencionar los más conocidos. Simplemente llenaremos las celdas de la siguiente manera:

\tablaSmallSinColores{Ejemplo de \textit{CSV}}{ccc}{ejemplo-csv}
{
	\textbf{email} & \textbf{nombre} & \textbf{rol} \\
}
{
	email@mail.com & pepito & POTUS \\
	secret@mail.com & 007 Agent & slave \\
}

Como se ve, en cada columna hay un tipo de dato, y el nombre de dicho dato se determina mediante la cabecera de dicha columna. Las celdas inferiores a la misma contendrán los datos de dicho valor para cada uno de los usuarios. Lo mismo pasa con el resto de las columnas.

Pista: para introducir estos datos en la hoja de cálculo correspondiente, normalmente se pueden pegar directamente desde una tabla en un navegador, etc.

Una vez los datos en la hoja de cálculo el programa correspondiente tendrá un pequeño asistente para conseguir exportar a \textit{CSV} los valores introducidos. Dicha orden suele encontrarse en el menú \texttt{<<Archivo>>}, bajo la opción \texttt{<<Exportar...>>}, \texttt{<<Exportar como...>>}, \texttt{<<Guardar como...>>}, etc. Normalmente podremos emplear los parámetros por defecto del asistente, pero no nos olvidemos de guardar el archivo en la carpeta \texttt{<<instance>>} con el nombre adecuado.

Nota: En el momento de redactar esta sección, el único campo necesario es el \textit{email}, pero para saber a ciencia cierta cuáles son los campos por almacenar, conviene echar un vistazo al \textit{script} de creación en \texttt{<<WebPage\slash MyApp/sql\textunderscore scripts\slash schema.sql>>}.

\subsection{Lanzando el servidor}
Ahora, bajo la carpeta \texttt{<<Webpage>>} encontraremos el fichero \texttt{<<runserver.py>>} al que haremos referencia con la orden:

\noindent\verb|$ python3 <ruta proyecto>/Webpage/runserver.py|

Et \textit{voilà}: el servidor está lanzado, y el terminal nos indica la dirección que debemos introducir para consultar el contenido: \texttt{<<localhost:5000>>} o \texttt{<<127.0.0.1:5000>>} como se prefiera. Por fin debería ver la interfaz de la aplicación.



\section{Manual del programador}\label{manual-programador}
Veamos los diferentes elementos que nos pueden ser de utilidad a la hora de realizar cambios en el proyecto.

\subsection{Instalando dependencias Node}
Para labores de desarrollo, necesitaremos tener instalado Node y algunas dependencias extra. Podremos si tecleamos desde la carpeta \texttt{<<TFG/WebPage/>>} el siguiente comando:

\noindent\verb|$ npm install|

Éste y todos los comandos que sean con npm, deberán ser ejecutados desde la misma ruta.

\subsection{Transpilación JavaScript}
Durante el desarrollo del proyecto, separamos el código JavaScript en diferentes fuentes, que requieren para funcionar de realizar una transpilación a un estándar que comprendan los navegadores actuales. Aunque éstos soportan gran parte de las características de \textit{ES6} (\textit{ES2015}), estándar en el que hemos escrito el fuente original, hay elementos que todavía no soportan, como los \textit{import} entre las diferentes clases. Adicionalmente, aprovechamos para hacer el archivo destino más pequeño, en un proceso denominado \textit{minifying}.
Para ello, vamos a empaquetar el código de una manera más adecuada, y nos ayudaremos de rollup:

\noindent\verb|$ npm run build|

Si por ejemplo estamos desarrollando, sería molesto llamar a esta función cada vez que hiciésemos un cambio. Para ello, hemos implementado una configuración que nos permitirá invocar una sola vez a un comando de transpilación, y cada vez que realicemos un cambio automáticamente se generará el fichero destino en formato \textit{minified}. Para hacer esto, tenemos que llamar al comando:

\noindent\verb|$ npm run build dev|

\subsection{Construir la documentación JavaScript}
Para hacerlo, tenemos otro \textit{script} incluido en la configuración de Node para facilitarnos la tarea. Solamente hay que escribir:

\noindent\verb|$ npm run jsdoc|

\subsection{Construir la documentación de Python}
Construir la documentación de Python es igual de sencillo:

\noindent\verb|$ npm run pydoc-http|

Eso sí, hay que tener en cuenta que éste comando no nos avisa de que sigamos algunas pautas recomendables, así que necesitamos de otro comando para revisar la sintaxis:

\noindent\verb|$ npm run pydoc-style|

\subsection{Usando el analizador de modelos: eliminando puntos superfluos}
Con el fin de mejorar los modelos, añadimos varias funciones a nuestras herramientas con el fin de <<recortar>> en la medida de lo posible el espacio que ocupan los modelos, además de evitar errores posteriores con los mismos.

Hemos empaquetado toda la funcionalidad en un módulo Python, por lo que abriremos la dicha consola sobre la carpeta \texttt{<<Resources>>}:

\noindent\verb|$ python3|

A continuación, cargaremos la función a emplear:

\noindent\verb|>>> from ply_utils import process_ply_file|

Con la función cargada, aplicaremos los parámetros necesarios.

\noindent\verb|>>> process_ply_file('una ruta de archivo', 'encoding')|

La ruta de archivo puede ser tanto relativa como absoluta.
El parámetro de \texttt{encoding} es opcional, y si se incluye debe ser \texttt{<<b'ascii'>>}, \texttt{<<b'binary\_little\_endian'>>} o \texttt{<<b{'binary\_big\_endian'}>>}.

Este último parámetro es el que nos permitirá comprimir los archivos \textit{ASCII} en formato binario, más compacto. Así mismo, podremos generar un fichero \textit{ASCII} a partir de uno binario.

\subsection{Estructura de directorios}
\noindent Para comenzar, mostraremos los archivos existentes en la raíz del proyecto:
\begin{itemize}
	\item \textbf{.codeclimate.yml} Contiene la configuración para calidad del código fuente de CodeClimate\footnote{\url{https://codeclimate.com/github/Alberto-Vivar/3D-Viewer}}, un comprobador automático de código.
	\item \textbf{.gitignore} Posee los diferentes elementos que el sistema \textit{GIT} debe evitar revisar.
	\item \textbf{README.md} Archivo léeme en formato \textit{Markdown} que aparece en la portada de GitHub.
\end{itemize}

Ahora mostraremos las carpetas disponibles en la raíz del proyecto:
\begin{itemize}
	\item Documentación
	\item WebApp
	\item Resources
\end{itemize}

\noindent A continuación las describiremos en mayor detalle.

\subsubsection{Documentación}
En ella tendremos el conjunto de documentaciones generadas para el proyecto, cuyas carpetas son:
\begin{itemize}
	\item \textbf{javascript} En ella tenemos la documentación generada para la parte Javascript, esto es, toda la lógica e interfaz del visor.
	\item \textbf{LaTex} Contiene la memoria y anexos del proyecto.
	\item \textbf{python} Posee la documentación generada mediante Sphinx\footnote{\url{http://www.sphinx-doc.org/en/stable/}} para el servidor.
\end{itemize}

\subsubsection{WebApp}
En ella se encuentra definido tanto el servidor como la página web en si misma. Veamos los directorios que la componen:
\begin{itemize}
	\item \textbf{instance} Aunque no es un directorio incluido en el repositorio, debemos mencionarlo, puesto que en él incluiremos algunas configuraciones propias de la instancia que estemos desplegando o desarrollando y que no queramos incluir en la versión que subamos al servidor. Algunos archivos de utilidad que meteremos son:
		\begin{itemize}
			\item \textbf{config.py} En este archivo incluiremos algunos parámetros de configuración que debemos sobrescribir, como el estado de \texttt{<<DEBUG>>}, o el secreto de aplicación \texttt{<<SECRET\_KEY>>}.
			\item \textbf{users\_to\_import.csv} Es la ruta por defecto para el archivo \textit{CSV} que nos permite importar la lista de usuarios a los que queremos dar permiso.
		\end{itemize}
	\item \textbf{MyApp} En él está la aplicación en sí misma, casi toda la lógica de negocio y toda la visualización.
		\begin{itemize}
			\item \textbf{sql\_scripts} Incluye los \textit{scripts} de utilidad para la base de datos.
			\item \textbf{static} Directorio para cargar elementos estáticos de las páginas.
			\begin{itemize}
				\item \textbf{js} \textit{Scripts} que importaremos. Aquí tendremos el código JavaScript una vez transpilado, y por tanto, gran parte de la lógica del visor.
				\item \textbf{uploads} En este directorio terminan los modelos, además de los \textit{PNG} como sus miniaturas.
			\end{itemize}
			\item \textbf{templates} En él se encuentran las plantillas en formato jinja2\footnote{\url{http://jinja.pocoo.org/}}.
			\item \textbf{translations} En este directorio encontraremos los ficheros plantilla para poder realizar la traducción con Babel.
			\item \textbf{babel.cfg} Configuración con la que Babel busca las etiquetas identificadoras.
			\item \textbf{forms.py} Contiene constructores de los diferentes formularios.
			\item \textbf{\_\_init\_\_.py} Constructor del módulo.
			\item \textbf{messages.pot} Binario con las traducciones de Babel ya realizadas
			\item \textbf{User.py} Clase necesaria para la gestión de usuarios.
			\item \textbf{users.db} Base de datos que alberga la información de los usuarios admitidos.
			\item \textbf{views.py} Contiene los diferentes \textit{endpoints} de nuestro servidor.
		\end{itemize}
	\item \textbf{src} Código fuente de JavaScript sin compilar.
	\item \textbf{typings} Archivos de configuración para nuestro \textit{IDE} (Visual Studio Code).
\end{itemize}

Ahora, veamos los archivos que contiene:
\begin{itemize}
	\item \textbf{config.py} Archivo de configuración predeterminada. Estos parámetros se verán sobrescritos por los añadidos en \texttt{instance/config.py}.
	\item \textbf{install\_run.bat} \textit{Script} para Windows que genera un entorno virtual, lo registra, instala las dependencias Python, y lanza el servidor.
	\item \textbf{install\_run.sh} El mismo \textit{script}, pero para Linux.
	\item \textbf{jsconfig.json} Archivo de configuración para \textit{VSCode}.
	\item \textbf{package.json} Define las dependencias y comandos disponibles llamándolo desde npm (Node).
	\item \textbf{requirements.txt} Requisitos de los módulos para Python.
	\item \textbf{rollup.config.js} Configuración para el \textit{plugin} que empaqueta el código.
	\item \textbf{runserver.py} \textit{Script} que carga el módulo principal para lanzar el servidor.
	\item \textbf{typings.json} Configuración IntelliSense de Visual Studio Code.
\end{itemize}

\subsubsection{Resources}
Contiene algunos recursos que no sabíamos donde meter, pues no pertenecen estrictamente a ninguna de las partes anteriores. Entre sus elementos se encuentran los archivos <<fuente>> de los diagramas, o los generadores de informes para los archivos \textit{PLY}, que posiblemente integremos en un futuro sobre el servidor.

\subsection{Babel - Internacionalización}
Como el proceso ya está iniciado, en el manual detallaremos la actualización y no el comienzo.
La instalación de Babel es un requisito incluido en \texttt{<<requirements.txt>>}, así que podemos instalarlo junto con el resto de dependencias del proyecto (preferentemente en el entorno virtual):

\noindent\verb|$ pip3 install -r requirements.txt|

Los ficheros que Babel procesa están determinados por babel.cfg, así que cualquier necesidad extra deberemos reflejarla en dicho archivo.
Al añadir o eliminar las cadenas a procesar del código, necesitamos que Babel sepa cuales son sus cambios, así que le pedimos las extraiga:

\noindent\verb|$ pybabel extract -F babel.cfg -k lazy_gettext -o messages.pot .|

Nota: Ojo al punto final, no es una errata, tiene significado (directorio actual).

Aunque es improbable que dejemos de emplear las sustituciones perezosas (son las lazy\_gettext), si dejasen de ser necesarias podríamos quitar la parte \texttt{<<-k lazy\_gettext>>} del comando.
Si queremos añadir un idioma que todavía no existe, entonces tenemos que crear un fichero inicial del mismo:

\noindent\verb|$ pybabel init -i messages.pot -d translations -l es|

El parámetro \texttt{<<-d translations>>} dictamina que el nuevo fichero tendrá como destino la carpeta translations, para que tengamos todas las traducciones juntas.
El parámetro \texttt{<<-l es>>} determina el lenguaje; en este caso es el castellano, así que si queremos otro diferente tenemos que buscar la abreviatura adecuada\footnote{\url{http://babel.pocoo.org/en/latest/api/languages.html\#module-babel.languages}} según el proyecto que hemos empleado (flask-babel)\footnote{\url{https://github.com/python-babel/flask-babel}}\footnote{\url{https://pythonhosted.org/Flask-Babel/}}, tendríamos que revisar la versión de \textit{CLDR} empleada por Babel.

Si el idioma ya estaba creado, entonces no queremos que nos sobre-escriba lo que ya teníamos traducido. Entonces, le pediremos nos actualice las referencias mediante:

\noindent\verb|$ pybabel update -i messages.pot -d translations|

Añadirá las nuevas cadenas, y aquellas que ya no encuentre, cambiará su marca de \texttt{<<\#:>>} a \texttt{<<\#\textasciitilde>>}.

El único paso que nos quedará entonces será el de generar los ficheros que emplea Babel:

\noindent\verb|$ pybabel compile -d translations|

Y eso es todo, ya podemos tener las últimas etiquetas traducidas de forma dinámica.



\section{Problemas puntuales}\label{manual-programador-problemas-puntuales}
El error \texttt{<<No enviroment provided>>} salta a la hora de llamar activate si el directorio de trabajo actual de la consola es la carpeta bin del entorno virtual.
\newline
Solución: cambiar el directorio de trabajo al menos una carpeta más <<arriba>>.

Al crear el entorno virtual no encuentra pip.
\newline
Solución 1: usar la opción \texttt{<<\text{--without-pip}>>} durante la creación y posteriormente instalar \textit{PIP} en el entorno virtual.
\newline
\noindent\verb|$ sudo apt-get install python3-pip|
\newline
Solución 2: usar otra distribución de Python.

A la hora de generar los archivos necesarios para Babel, salta el siguiente error:
\newline
{\scriptsize\noindent\verb|UndefinedEnvironmentName: 'extra' does not exist in evaluation environment.|}
\newline
Solución: actualizar setuptools\footnote{\url{http://stackoverflow.com/questions/43556482/pybabel-extract-undefinedenvironmentname-extra-does-not-exist-in-evaluation-e}}



\section{Pruebas del sistema}
Por problemas de tiempo, y por no haber realizado el proyecto mediante la filosofía \textit{TDD}~\cite{wiki:TDD}, no se han realizado pruebas formales del sistema.
